{
  parserClass="com.google.bamboo.soy.parser.SoyParser"
  parserUtilClass="com.google.bamboo.soy.parser.SoyParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Soy"
  psiImplClassSuffix="Impl"
  psiPackage="com.google.bamboo.soy.parser"
  psiImplPackage="com.google.bamboo.soy.parser.impl"

  elementTypeHolderClass="com.google.bamboo.soy.parser.SoyTypes"
  elementTypeClass="com.google.bamboo.soy.parser.SoyElementType"
  tokenTypeClass="com.google.bamboo.soy.lexer.SoyTokenType"

  implements(".*Statement")="com.google.bamboo.soy.elements.StatementBase"
  implements("Begin.*|End.*|.*Tag")="com.google.bamboo.soy.elements.TagElement"
  implements("(Css|Lb|LetSingle|Nil|Xid|Rb|Sp|Whitespace|Print)Statement")
      = ["com.google.bamboo.soy.elements.StatementBase" "com.google.bamboo.soy.elements.TagElement"]


  extends(".*Expr|VariableReferenceIdentifier")=Expr
  consumeTokenMethod(".*Expr")="consumeTokenFast"

  tokens = [
    ALIAS = "alias"
    AMP_AMP = "&&"
    AND = "and"
    AS = "as"
    AT_PARAM = "@param"
    AT_PARAM_OPT = "@param?"
    AT_INJECT = "@inject"
    AT_INJECT_OPT = "@inject?"
    BOOL_LITERAL = "regexp:false|true"
    CALL = "call"
    CARRIAGE_RETURN = "\\r"
    CASE = "case"
    COLON = ":"
    COMMA = ","
    CSS="css"
    DEFAULT = "default"
    DELCALL = "delcall"
    DELPACKAGE = "delpackage"
    DELTEMPLATE = "deltemplate"
    DOLLAR = "$"
    DOT = "."
    DOT_NULL_CHECK = "?."
    ELSE = "else"
    ELSEIF = "elseif"
    EQUAL = "="
    EQUAL_EQUAL = "=="
    EXCLAMATION = "!"
    FALLBACKMSG = "fallbackmsg"
    FOR = "for"
    FOREACH = "foreach"
    GREATER = ">"
    GREATER_EQUAL = ">="
    IF = "if"
    IFEMPTY = "ifempty"
    IN = "in"
    INDEX_NULL_CHECK = "?["
    LB = "lb"
    LBRACE = "{"
    LBRACE_LBRACE = "{{"
    LBRACE_SLASH = "{/"
    LBRACE_LBRACE_SLASH = "{{/"
    LESS = "<"
    LESS_EQUAL = "<="
    LET = "let"
    LITERAL = "{literal}"
    MINUS = "-"
    MSG = "msg"
    NAMESPACE = "namespace"
    NEWLINE_LITERAL = "\\n"
    NIL = "nil"
    NOT = "not"
    NOT_EQUAL = "!="
    OR = "or"
    PARAM = "param"
    PARENS_CLOSE = ")"
    PARENS_OPEN = "("
    PERCENT = "%"
    PIPE = "|"
    PIPE_PIPE = "||"
    PLURAL = "plural"
    PLUS = "+"
    PRINT = "print"
    QUESTIONMARK = "?"
    RB = "rb"
    RBRACE = "}"
    RBRACE_RBRACE = "}}"
    SELECT = "select"
    SLASH = "/"
    SLASH_RBRACE = "/}"
    SLASH_RBRACE_RBRACE = "/}}"
    SP = "sp"
    SQUARE_CLOSE = "]"
    SQUARE_OPEN = "["
    STAR = "*"
    SWITCH = "switch"
    TAB = "\\t"
    TEMPLATE = "template"
    TERNARY_COALESCER = "?:"
    TESTING_WHITESPACE = "regexp:[ \n\t\r\f]+"
    XID="xid"

    /* Types */
    ANY = "any"
    STRING = "string"
    BOOL = "bool"
    INT = "int"
    FLOAT = "float"
    NUMBER = "number"
    HTML = "html"
    URI = "uri"
    JS = "js"
    ATTRIBUTES = "attributes"
    LIST = "list"
    MAP = "map"

    DOC_COMMENT_BLOCK = "regexp:(/\**([^*]|(\*+[^*/]))*(\*+/))"
    COMMENT_BLOCK = "regexp:(/\*([^*]|(\*+[^*/]))*(\*+/))"
    HTML_COMMENT ="regexp:<!--([^\r\n]|(\r|\n|\r\n))*-->"

    IDENTIFIER_WORD = "regexp:[a-zA-Z_]([a-zA-Z_0-9])*"
    QUALIFIED_IDENTIFIER = "regexp:\.?[a-zA-Z_]([a-zA-Z_0-9])(\.[a-zA-Z_]([a-zA-Z_0-9]))*"
    CSS_IDENTIFIER_LITERAL = "regexp:%?[a-zA-Z_-]([a-zA-Z_0-9-])*"

    STRING_LITERAL = "regexp:'([^\r\n'\\]|\\.)*'"
    MULTI_LINE_STRING_LITERAL = "regexp:'([^'\\]|\\([^]))*'"

    INTEGER_LITERAL = "regexp:[0-9]+"
    FLOAT_LITERAL = "regexp:([0-9]+\.[0-9]+(e((\+|-)?[0-9]+))?)|([0-9]+(e((\+|-)?[0-9]+))?)"

    OTHER = "regexp:."
  ]
}


// Root rule

FileInput ::= BlockList

// Identifier

private KeywordsAllowedInIdentifiers ::=
    ANY | AS | ATTRIBUTES | BOOL | CSS | FLOAT | HTML | INT | JS | LB | LIST |
    MAP | MSG | NIL | NUMBER | PLURAL | RB | SP | STRING | URI | XID

// A single identifier token: foo, bar, any, int
private PlainIdentifier ::= IDENTIFIER_WORD | KeywordsAllowedInIdentifiers

// A variable reference: $foo, $bar, $template
private VariableIdentifier ::= DOLLAR IDENTIFIER_WORD {
  pin = 1;
}

private FieldAccess ::= (DOT | DOT_NULL_CHECK) IDENTIFIER_WORD {
  pin = 1
}

// A sequence of tokens representing namespace, template or function id: my.name.space, .template
private QualifiedIdentifier ::= QUALIFIED_IDENTIFIER

// A valid css identifier: dashes are allowed, dots are not: -foo-bar, %foo-bar, foo
CssIdentifier ::= CSS_IDENTIFIER_LITERAL | PlainIdentifier

// A lax rule for xid identifier: dashes are allowed, dots are allowed: %-foo.bar, %foo-bar, foo
// Should be caught by annotation.
XidIdentifier ::= (DOT? (CSS_IDENTIFIER_LITERAL | PlainIdentifier))+

TemplateDefinitionIdentifier ::= QualifiedIdentifier {
  mixin="com.google.bamboo.soy.elements.impl.TemplateDefinitionMixin"
  implements="com.google.bamboo.soy.elements.TemplateDefinitionElement"
  stubClass = "com.google.bamboo.soy.stubs.TemplateDefinitionStub"
  elementTypeFactory = "com.google.bamboo.soy.stubs.StubFactory.getType"
}

TemplateReferenceIdentifier ::= QualifiedIdentifier {
  mixin="com.google.bamboo.soy.elements.impl.IdentifierMixin"
  implements="com.google.bamboo.soy.elements.IdentifierElement"
  methods=[getReference]
}

VariableReferenceIdentifier ::= VariableIdentifier {
  mixin="com.google.bamboo.soy.elements.impl.IdentifierMixin"
  implements="com.google.bamboo.soy.elements.IdentifierElement"
  methods=[getReference]
}

VariableDefinitionIdentifier ::= VariableIdentifier {
  mixin="com.google.bamboo.soy.elements.impl.VariableDefinitionMixin"
  implements="com.google.bamboo.soy.elements.VariableDefinitionElement"
  methods=[setName getName]
}

ParamDefinitionIdentifier ::= PlainIdentifier {
  mixin="com.google.bamboo.soy.elements.impl.VariableDefinitionMixin"
  implements="com.google.bamboo.soy.elements.VariableDefinitionElement"
  methods=[setName getName]
 }

ParamSpecificationIdentifier ::= PlainIdentifier {
  mixin="com.google.bamboo.soy.elements.impl.ParamIdentifierMixin"
  implements="com.google.bamboo.soy.elements.ParamIdentifierElement"
  methods=[getReference]
}

NamespaceDeclarationIdentifier ::= QualifiedIdentifier {
  mixin="com.google.bamboo.soy.elements.impl.NamespaceDeclarationMixin"
  implements="com.google.bamboo.soy.elements.NamespaceDeclarationElement"
  stubClass = "com.google.bamboo.soy.stubs.NamespaceDeclarationStub"
  elementTypeFactory = "com.google.bamboo.soy.stubs.StubFactory.getType"
}

NamespaceIdentifier ::= QualifiedIdentifier

AliasIdentifier ::= QualifiedIdentifier

TypeIdentifier ::= PlainIdentifier

PackageIdentifier ::= QualifiedIdentifier

FieldIdentifier ::= PlainIdentifier

AttributeNameIdentifier ::= PlainIdentifier

FunctionIdentifier ::= PlainIdentifier

// Literals

ValueLiteral ::= NumberLiteral | AnyStringLiteral | BOOL_LITERAL

private NumberLiteral ::= INTEGER_LITERAL | FLOAT_LITERAL | DOT FLOAT_LITERAL

AnyStringLiteral ::= STRING_LITERAL | MULTI_LINE_STRING_LITERAL {
  mixin="com.google.bamboo.soy.elements.impl.IdentifierMixin"
  implements="com.google.bamboo.soy.elements.IdentifierElement"
  methods=[getReferences]
}

private Brace ::= LBRACE | LBRACE_LBRACE | LBRACE_SLASH | LBRACE_LBRACE_SLASH | RBRACE | RBRACE_RBRACE | SLASH_RBRACE | SLASH_RBRACE_RBRACE
private recoverEndOfTag ::= !(Brace | LITERAL | LITERAL_DOUBLE)
private meta BracedTag ::= <<ClosedBracedTag <<p>>>> | <<OpenBracedTag <<p>>>>
private meta ClosedBracedTag ::= (LBRACE | LBRACE_LBRACE) <<p>> (SLASH_RBRACE | SLASH_RBRACE_RBRACE)

private meta OpenBracedTag ::= <<OpenTagInner <<p>>>> (RBRACE | RBRACE_RBRACE) {
  pin = 1
}
private meta OpenTagInner ::= (LBRACE | LBRACE_LBRACE) <<p>> {
  recoverWhile = "recoverEndOfTag"
}

private meta EndTag ::= <<EndTagInner <<p>>>> (RBRACE | RBRACE_RBRACE) {
  pin = 1
}
private meta EndTagInner ::= (LBRACE_SLASH | LBRACE_LBRACE_SLASH) <<p>> {
  recoverWhile = "recoverEndOfTag"
}


// Possible ending tags

EndDelTemplateTag ::= <<EndTag DELTEMPLATE>>
EndForeachTag ::= <<EndTag FOREACH>>
EndForTag ::= <<EndTag FOR>>
EndIfTag ::= <<EndTag IF>>
EndLetTag ::= <<EndTag LET>>
EndMsgTag ::= <<EndTag MSG>>
EndTemplateTag ::= <<EndTag TEMPLATE>>
EndParamTag ::= <<EndTag PARAM>>

// Expanding on soy's hierarchical structure follows.

BlockList ::= (Block | OTHER | COMMENT_BLOCK | HTML_COMMENT)*

private Block ::= NamespaceBlock | AliasBlock | TemplateBlock | DelegatePackageBlock | CatchallBraces

CatchallBraces ::= <<BracedTag ()>> | <<EndTag ()>>

// Namespace block

NamespaceBlock ::= <<BracedTag NamespaceTagBody>>

private NamespaceTagBody ::= NAMESPACE NamespaceDeclarationIdentifier [AttributeList] {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// Alias block

AliasBlock ::= <<BracedTag AliasBody>>

private AliasBody ::= ALIAS NamespaceIdentifier [AS AliasIdentifier] {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// Template block

TemplateBlock ::= LocalTemplateBlock | DelegateTemplateBlock {
  mixin="com.google.bamboo.soy.elements.impl.TemplateBlockMixin"
  implements="com.google.bamboo.soy.elements.TemplateBlockElement"
  stubClass = "com.google.bamboo.soy.stubs.TemplateBlockStub"
  elementTypeFactory = "com.google.bamboo.soy.stubs.StubFactory.getType"
}

private LocalTemplateBlock ::= <<AbstractTemplateBlock TEMPLATE>>
private DelegateTemplateBlock ::= <<AbstractTemplateBlock DELTEMPLATE>>

private meta AbstractTemplateBlock ::=
    <<BeginTemplate <<p>>>>
    [AtParamList]
    [<<StatementList !()>>]
    <<EndTemplate <<p>>>> {
  pin = 1
}

meta BeginTemplate ::= <<BracedTag <<BeginTemplateBody<<p>>>>>>
meta EndTemplate ::= <<EndTag <<p>>>>

private meta BeginTemplateBody ::= <<p>> (TemplateDefinitionIdentifier [AttributeList] | AttributeList) {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

private AtParamList ::= (AtParamSingle [DocComment]| AtInjectSingle [DocComment])+

AtParamSingle ::= <<BracedTag AtParamBody>> {
  implements = "com.google.bamboo.soy.elements.AtParamElement"
  mixin = "com.google.bamboo.soy.elements.impl.AtParamMixin"
  stubClass = "com.google.bamboo.soy.stubs.AtParamStub"
  elementTypeFactory = "com.google.bamboo.soy.stubs.StubFactory.getType"
}

DocComment ::= DOC_COMMENT_BLOCK

private AtParamBody ::= (AT_PARAM | AT_PARAM_OPT) ParamDefinitionIdentifier COLON TypeExpression {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

AtInjectSingle ::= <<BracedTag AtInjectBody>> {
  implements = "com.google.bamboo.soy.elements.AtInjectElement"
  mixin = "com.google.bamboo.soy.elements.impl.AtInjectMixin"
}

private AtInjectBody ::= (AT_INJECT | AT_INJECT_OPT) ParamDefinitionIdentifier COLON TypeExpression {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

TypeExpression ::= UnionType | CompoundType | PrimitiveType

PrimitiveType
  ::=
    ANY | STRING | BOOL | INT | FLOAT | NUMBER | HTML | NULL | QUESTIONMARK |
    URI | JS | ATTRIBUTES | TypeIdentifier

CompoundType ::= ListType | MapType | RecordType

ListType ::= LIST LESS TypeExpression GREATER {
  pin = 2
}

MapType ::= MAP LESS TypeExpression COMMA TypeExpression GREATER {
  pin = 2
}

UnionType ::= (CompoundType | PrimitiveType) PIPE TypeExpression {
  pin = 2
}

RecordType ::= SQUARE_OPEN RecordTypeField (COMMA RecordTypeField)* SQUARE_CLOSE {
  pin = 1
}

RecordTypeField ::= FieldIdentifier COLON TypeExpression {
  pin = 2
}


// DelPackage block

DelegatePackageBlock ::= <<BracedTag DelegatePackageTagBody>>

private DelegatePackageTagBody ::= DELPACKAGE PackageIdentifier {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// Attribute lists

private AttributeList ::= AttributeKeyValuePair+

AttributeKeyValuePair ::= AttributeNameIdentifier EQUAL AnyStringLiteral {
  pin = 2
}

// Statements

external endOfStatementBlock ::= parseEndOfStatementBlock

// Should consume everything until the provided threshold rule or any end tag.
// Should only expect statements.
// Should (ideally) mark everything else as an error.
meta StatementList ::= (Statement | !(<<p>> | endOfStatementBlock) CatchallBraces)+ {
  recoverWhile = "!(<<p>> | endOfStatementBlock)"
  implements = "com.google.bamboo.soy.elements.StatementListElement"
  mixin = "com.google.bamboo.soy.elements.impl.StatementListMixin"
}

// ! It is very important to have the following structure
// StatementList
// |- OTHER
// |- Some other statement
// for the formatter to work, see SoyFormattingModelBuilder
//
// Please do not change the visibility of these rules, unless you are sure
// what you are doing.

private Content ::= OTHER

private Statement ::=
    SingleTagStatement
  |
    CallStatement
  |
    ChoiceStatement
  |
    ForStatement
  |
    ForeachStatement
  |
    IfStatement
  |
    LetCompoundStatement
  |
    LiteralStatement
  |
    MsgStatement
  |
    Content


private SingleTagStatement ::=
    CssStatement
  |
    LbStatement
  |
    LetSingleStatement
  |
    NilStatement
  |
    XidStatement
  |
    RbStatement
  |
    SpStatement
  |
    WhitespaceStatement
  |
    PrintStatement

// A wrapper for [StatementList] that parses all statements in an unexpected context.

meta UnexpectedStatements ::= <<StatementList (<<p>>)>>

// For

ForStatement
  ::= BeginFor
    [<<StatementList !()>>]
    EndForTag {
  pin = 1
  implements = "com.google.bamboo.soy.elements.ForStatementElement"
  mixin = "com.google.bamboo.soy.elements.impl.ForStatementMixin"
}

BeginFor ::= <<BracedTag BeginForTagBody>>

private BeginForTagBody ::= FOR VariableDefinitionIdentifier IN Expr {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// Foreach

ForeachStatement
  ::=
    BeginForeach
      [<<StatementList (IfEmptyTag)>>]
    [IfEmptyTag
      [<<StatementList !()>>]]
    EndForeachTag {
  pin = 1
  implements = "com.google.bamboo.soy.elements.ForeachStatementElement"
  mixin = "com.google.bamboo.soy.elements.impl.ForeachStatementMixin"
}

IfEmptyTag ::= <<BracedTag IFEMPTY>>

BeginForeach ::= <<BracedTag BeginForeachTagBody>>

private BeginForeachTagBody ::= FOREACH VariableDefinitionIdentifier IN Expr {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// If

IfStatement
  ::=
    BeginIf
    [<<StatementList (ElseTag | BeginElseIf)>>]
    [ElseIfClauseList]
    [ElseTag [<<StatementList !()>>]]
    EndIfTag {
  pin = 1
  implements = ["com.google.bamboo.soy.elements.StatementBase" "com.google.bamboo.soy.elements.TagBlockElement"]
}

BeginIf ::= <<BracedTag BeginIfTagBody>>

private BeginIfTagBody ::= IF Expr {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

private ElseIfClauseList
  ::=
    BeginElseIf
      [<<StatementList (ElseTag | BeginElseIf)>>]
    [ElseIfClauseList] {
  pin = 1
}

BeginElseIf ::= <<BracedTag BeginElseIfTagBody>>

private BeginElseIfTagBody ::= ELSEIF Expr {
  pin = 1
}

ElseTag ::= <<BracedTag ELSE>>



/*
 * CALL STATEMENTS
 */

private CallStatement ::= DirectCallStatement | DelCallStatement

DirectCallStatement ::= <<AbstractCallStatement CALL>> {
  implements="com.google.bamboo.soy.elements.CallStatementBase"
}

DelCallStatement ::= <<AbstractCallStatement DELCALL>> {
  implements="com.google.bamboo.soy.elements.CallStatementBase"
}

private meta AbstractCallStatement ::=
    !(<<ClosedBeginCall <<p>>>>) <<AbstractCallStatementBlock <<p>>>>
  | <<BeginCall <<p>>>>
private meta AbstractCallStatementBlock ::= <<BeginCall <<p>>>> ParamList <<EndCall <<p>>>> {
   pin = 1
}
meta BeginCall ::= <<BracedTag <<CallTagBody <<p>>>>>>
meta EndCall ::= <<EndTag <<p>>>>

private meta ClosedBeginCall ::= <<ClosedBracedTag <<CallTagBody <<p>>>> >>
private meta CallTagBody ::= <<p>> (TemplateReferenceIdentifier [AttributeList] | AttributeList) {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// ParamList
private ParamList ::= (ParamListElement | <<UnexpectedStatements (BeginParamTag)>>)* {
  recoverWhile = "!(endOfStatementBlock)"
}

ParamListElement ::= !<<ClosedBracedTag BeginParamTagBody>> BlockParamListElement | BeginParamTag {
  implements = "com.google.bamboo.soy.elements.ParamListElementBase"
}

private BlockParamListElement ::= BeginParamTag <<StatementList (BeginParamTag)>> EndParamTag {
  pin = 1
}

BeginParamTag ::= <<BracedTag BeginParamTagBody>>

private BeginParamTagBody ::= PARAM (ParamSpecificationIdentifier COLON Expr | AttributeList | ParamSpecificationIdentifier [AttributeList]) {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}


/*
 * MULTIPLE CHOICE STATEMENTS
 */

private ChoiceStatement ::= SwitchStatement | SelectStatement | PluralStatement

SwitchStatement ::= <<AbstractChoiceStatement SWITCH>> {
  implements = "com.google.bamboo.soy.elements.ChoiceStatementBaseElement"
}

SelectStatement ::= <<AbstractChoiceStatement SELECT>> {
  implements = "com.google.bamboo.soy.elements.ChoiceStatementBaseElement"
}

PluralStatement ::= <<AbstractChoiceStatement PLURAL>> {
 implements = "com.google.bamboo.soy.elements.ChoiceStatementBaseElement"
}

private meta AbstractChoiceStatement ::=
    <<BeginChoice <<p>>>>
    CaseAndDefaultClauses
    <<EndChoice <<p>>>> {
  pin = 1
}

meta BeginChoice ::= <<BracedTag <<AbstractBeginChoiceStatementBody <<p>>>>>>
meta EndChoice ::= <<EndTag <<p>>>>
private meta AbstractBeginChoiceStatementBody ::= <<p>> Expr [AttributeKeyValuePair] {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// Case and default clauses

// Statements are only "unexpected" before the first {case} or {default} tag. After that they are
// consumed by the appropriate *Clause rule.

private CaseAndDefaultClauses
  ::=
    [<<UnexpectedStatements (BeginCaseClause | DefaultTag)>>]
    (CaseClause | DefaultClause)*

CaseClause ::= BeginCaseClause [<<StatementList (BeginCaseClause | DefaultTag)>>] {
  pin = 1
}

BeginCaseClause ::= <<BracedTag BeginCaseClauseTagBody>>

private BeginCaseClauseTagBody ::= CASE CommaSeparatedExpressionList {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

DefaultClause ::= DefaultTag [<<StatementList (BeginCaseClause | DefaultTag)>>] {
  pin = 1
}

DefaultTag ::= <<BracedTag DEFAULT>>



/*
 * SIMPLE STATEMENTS
 */

// Css statement

CssStatement ::= <<BracedTag CssStatementTagBody>>

private CssStatementTagBody ::= CSS CssIdentifier

// Xid statement

XidStatement ::= <<BracedTag XidStatementTagBody>>

private XidStatementTagBody ::= XID XidIdentifier

// Let statement

LetSingleStatement ::= <<BracedTag LetSingleTagBody>>

private LetSingleTagBody ::= LET VariableDefinitionIdentifier COLON Expr {
  pin = 3
  recoverWhile = "recoverEndOfTag"
}

LetCompoundStatement ::= BeginLet [<<StatementList !()>>] EndLetTag {
  pin = 1
  implements = ["com.google.bamboo.soy.elements.StatementBase" "com.google.bamboo.soy.elements.TagBlockElement"]
}

BeginLet ::= <<BracedTag BeginLetTagBody>>

private BeginLetTagBody ::= LET VariableDefinitionIdentifier [AttributeKeyValuePair] {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

// Literal statement

LiteralStatement ::= (LITERAL Content END_LITERAL) | (LITERAL_DOUBLE Content END_LITERAL_DOUBLE)

// Msg statement

MsgStatement
  ::=
    BeginMsg
      [<<StatementList (FallbackMsgTag)>>]
    [FallbackMsgTag
      [<<StatementList !()>>]]
    EndMsgTag {
  pin = 1
  implements="com.google.bamboo.soy.elements.MsgStatement"
}

BeginMsg ::= <<BracedTag BeginMsgTagBody>>

private BeginMsgTagBody ::= MSG AttributeList {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

FallbackMsgTag ::= <<BracedTag FallbackMsgTagBody>>

private FallbackMsgTagBody ::= FALLBACKMSG AttributeList {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

LbStatement ::= <<BracedTag LB>>

NilStatement ::= <<BracedTag NIL>>

RbStatement ::= <<BracedTag RB>>

SpStatement ::= <<BracedTag SP>>

// Print statement

PrintStatement ::= <<BracedTag PrintBody>>

private PrintBody ::= ImplicitPrintBody | ExplicitPrintBody

private ExplicitPrintBody ::= PRINT Expr [PIPE DirectiveList] {
  pin = 1
  recoverWhile = "recoverEndOfTag"
}

private ImplicitPrintBody ::= Expr [PIPE DirectiveList] [AttributeKeyValuePair]

private DirectiveList ::= Directive (PIPE Directive)*

Directive
  ::=
    FunctionIdentifier
  |
    FunctionIdentifier COLON ValueLiteral (COMMA ValueLiteral)*

CommaSeparatedExpressionList ::= Expr (COMMA Expr)* COMMA?

// Whitespace statement

WhitespaceStatement ::= <<BracedTag TAB>>|<<BracedTag NEWLINE_LITERAL>>|<<BracedTag CARRIAGE_RETURN>>

// Expressions
// https://developers.google.com/closure/templates/docs/concepts#expressions
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
Expr ::= NullCheckTernaryExpr
  | NullCheckBinExpr
  | OrBinExpr
  | AndBinExpr
  | BoolOrBinExpr
  | BoolAndBinExpr
  | CompBinExpr
  | RelCompBinExpr
  | AddBinExpr
  | MulBinExpr
  | UnaryExpr
  | AtomExpr

private AtomExpr ::= VariableReferenceIdentifier
  | LiteralExpr
  | FunctionCallExpr
  | FieldExpr
  | IndexExpr
  | ListExpr
  | ParenthesizedExpr

LiteralExpr ::= NumberLiteral | AnyStringLiteral

NullCheckTernaryExpr ::= Expr QUESTIONMARK Expr COLON Expr
NullCheckBinExpr ::= Expr TERNARY_COALESCER Expr
OrBinExpr ::= Expr OR Expr
AndBinExpr ::= Expr AND Expr
BoolOrBinExpr ::= Expr PIPE_PIPE Expr
BoolAndBinExpr ::= Expr AMP_AMP Expr
CompBinExpr ::= Expr (EQUAL_EQUAL | NOT_EQUAL) Expr
RelCompBinExpr ::= Expr (GREATER | GREATER_EQUAL | LESS_EQUAL | LESS) Expr
AddBinExpr ::= Expr (PLUS | MINUS) Expr
MulBinExpr ::= Expr (STAR | SLASH | PERCENT) Expr
UnaryExpr ::= (PLUS | MINUS | NOT | EXCLAMATION) Expr

FunctionCallExpr ::= FunctionIdentifier PARENS_OPEN [CommaSeparatedExpressionList] PARENS_CLOSE
FieldExpr ::= Expr FieldAccess
IndexExpr ::= Expr (SQUARE_OPEN | INDEX_NULL_CHECK) [CommaSeparatedExpressionList] SQUARE_CLOSE
ListExpr ::= SQUARE_OPEN [CommaSeparatedExpressionList] SQUARE_CLOSE
ParenthesizedExpr ::= PARENS_OPEN Expr PARENS_CLOSE
